# Efficient indexing of collections of signatures

\chaptermark {MHBT}

## Introduction

\todoin{
- CTB para 1
- In chapter 1, we introduced...
- To make practical use, we want to support efficient search.
- This means efficient indexing to support various kinds of queries.
- Ideally indices would support incremental update, n+1, search across multiple databases.
- CTB note: these are good motivating points. Put them in paragraph 2 and write complete sentences, and I can iterate on them.
- para 2, go into detail --
- Public genome databases
- Exponential growth
- Challenges in indexing, searching and updating the indices for collections of datasets
- Methods for indexing genomic datasets
- CTB actually not sure how to split these up, but suggest two paragraphs, one focused on basic types of questions, the other focused on practical issues. If you write complete sentences, I can iterate.
}

Searching for matches in large collection of datasets is challenging when hundreds of thousands of
them are available,
especially if they are partitioned and the data is not all present at the same place,
or too large to even be stored in a single system.
<!-- cite some methods, including SBT and Mantis -->

[@marchet_2019] classifies indexing strategies for querying large collections of
sequencing datasets into $k$-mer aggregative methods and color aggregative methods.
$k$-mer aggregative methods index the $k$-mer composition for each individual dataset,
and then build structures for retrieving the datasets where query $k$-mers is present.
Color aggregative methods index the full $k$-mer composition for all datasets,
and then assign a color representing an intersection of datasets where a $k$-mer is present.
This allows reduced space requirements,
since each $k$-mer is stored only once,
but needs extra structures for storing what datasets each color represents.

Both strategies allow the same class of queries,
but with different trade-offs and optimizations:
$k$-mer aggregative methods favor threshold queries
("what datasets contain more 60% of the query $k$-mers?")
while color aggregative methods tend to be more efficient for specific $k$-mer
queries ("what datasets contain this query $k$-mer?").

<!-- how to dive into hierarchical index and inverted index below? -->

### Hierarchical index

<!-- 'k-mer aggregative methods in (marchet 2019)' -->

Bloofi [@crainiceanu_bloofi:_2015] is a hierarchical index structure that
extends the Bloom Filter basic query to collections of Bloom Filters.
Instead of calculating the union of all Bloom Filters in the collection
(which would allow answering if an element is present in any of them)
it defines a tree structure where the original Bloom Filters are leaves,
and internal nodes are the union of all the Bloom Filters in their subtrees.
Searching is based on a breadth-first search,
with pruning when no matches are found at an internal level.
Bloofi can also be partitioned in a network,
with network nodes containing a subtree of the original tree and only being
accessed if the search requires it.

The Sequence Bloom Tree [@solomon_fast_2016] adapts Bloofi for genomic contexts,
rephrasing the problem as experiment discovery:
given a query sequence $Q$ and a threshold $\theta$,
which experiments contain at least $\theta$ of the original query $Q$?
Experiments are encoded in Bloom Filters containing the $k$-mer composition of transcriptomes,
and queries are transcripts.

Further developments focused on clustering similar datasets to prune search
early [@sun_allsome_2017] and developing more efficient representations for the
internal nodes [@solomon_improved_2017] [@harris_improved_2018] to use less
storage space and memory.

<!--
example figure for SBT:
http://www.texample.net/tikz/examples/merge-sort-recursion-tree/
-->

### Inverted index

<!-- 'color- aggregative methods in (marchet 2019)' -->

An inverted index is a mapping from words in a text back to its location inside
the text.
An example is the index in the back of a book,
containing a list of topics and in which page they are present.
Information retrieval system use inverted index to find the occurrences of
words in a text [@ziviani:2000].

In the signature collection indexing case,
the inverted index is a map of all hashes in the collection back to
the signature from where they originated.
Just as words can appear more than once in a text,
hashes show up in more than one signature,
so the inverted index maps a hash to a list of signatures IDs.

kraken has a similar index,
but uses a taxonomic ID for each dataset.
Datasets can share the same ID (taxon),
if they belong to the same taxon.
Moreover,
if a hash is present in more than one dataset
kraken also reduces the list of taxons to the lowest common ancestor (LCA),
which leads to reduced memory usage.
[@dasko:2018] explores how this LCA approach leads to decreased precision and sensitivity over time,
since more datasets are added to reference databases and the chance of a k-mer being present
in multiple datasets increases.

\todoin{
- mash screen has a similar index, but it is constructed on-the-fly using the
  distinct hashes in a sketch collection as keys,
  and the values are mapped to a hash occurrence counter in a query metagenome.

- sourmash LCA index is the opposite: it stores the hashes, but allow
  reconstructing the original sketch collection.
}

Efficient storage of the list of signatures IDs can also be achieved via representation of the list as colors,
where a color can represent one dataset or multiple datasets (if a hash is present in many of them).
Mantis [@pandey_mantis:_2017] uses this hash to color mapping
(and an auxiliary color table) to achieve reduced memory usage.

### Converting between indices

Both MHBT and LCA index can recover the original sketch collection.
In the MHBT case,
it outputs all the leaf nodes.
In the LCA index,
it reconstruct each sketch from the hash -> dataset ID mapping.
This allows trade-offs between storage efficiency,
distribution,
updating and query performance.

## Results

### Efficient similarity and containment queries

#### Index construction and updating

\todoin{

- 
- resource usage (time, cpu, mem)

}

#### Querying

\todoin{

- discuss COST (cost of single thread)
- sourmash indices benefit from more data. Inverted index
}


## Discussion

\todoin{
- CTB
- para 1 (can be more than one)
- summarize results, what kind of searches and updating these indices support.
- para 2:
- I think the point about any k-mer indices working can go here?
- Our implementation makes use of and highlights different tradeoffs in both standard (LCA) text indexing approaches as well as non-standard k-mer focused (SBT).
- make some deep point about how specifics of biological data affect use of indices in ways that are not so important for traditional text mining. e.g. lca indices support discovery of k-mers belonging to multiple genomes, SBTs can be organized in way to support locality that matches bio samples (evo relationships) that is not so important for regular text.
- for conclusion/future directions, worth noting that while both support gather (next chapter?), only SBT supports distributed, and incremental update, and...
}

### Limitations

\todoin{
- CTB
}

### Future directions

\todoin{
- Other indices
  * Fundamentally a scaled minhash is a subset of the k-mer composition of a
  dataset, so any index from https://www.biorxiv.org/content/10.1101/866756v1
  ("Data structures based on k-mers for querying large collections of sequencing datasets")
  can be used to scale,
  and given that gather is defined over a collection of signatures the indices
  can also be used to improve gather performance.

- sourmash index search is currently single threaded, but that's an implementation detail.
  Parallel queries are possible (in a shared read-only index)
- certain kinds of queries can be fully parallelized.
}

### Summary/Conclusion

\todoin{
- CTB
}
## Methods

\todoin{
- CTB
}
### Implementation

sourmash is implemented in Rust for the core performance-critical functionality,
and exposes a C API that is wrapped in Python for higher-level features.
This includes a Python API for interactive use,
as well as a command-line interface for more traditional bioinformatics workflows.



### Experiments
\todoin{
- CTB
}